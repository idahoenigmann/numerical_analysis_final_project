\documentclass[]{article}

\usepackage{amsfonts} 
\usepackage{amsmath}
\usepackage[margin=3cm]{geometry}
\usepackage{enumitem}
\usepackage{amsthm}

\renewcommand*{\proofname}{Beweis}

%opening
\title{Abschlussprojekt}
\author{Ida Hönigmann \and Fabian Dopf}

\begin{document}

\maketitle

\section*{Aufgabe 1: Aufwandsordnung numerischer Verfahren}
\subsection*{Teilaufgabe 1a:}
TODO Angabe 1a

\begin{proof}
	Annahme: $\forall N \in \mathbb{N}$ ist $p_N$, sodass $y_N \leq C N^{p_N}$ für ein $C > 0$.
	
	Für ein beliebiges $N \in \mathbb{N}$ gilt $\exists C_{1N}, C_{2N} > 0$ und $p_{1N}, p_{2N} > 0$ mit $y_N \leq C_{1N} N^{p_{1N}}$ und $y_{2N} \leq C_{2N} (2N)^{p_{2N}}$.
	
	Für $C:=max\{C_{1N}, C_{2N}\}$ und $p_N:=max\{p_{1N}, p_{2N}\}$ gilt $y_N \leq C_{1N} N^{p_{1N}} \leq C N^{p_N}$ und $y_{2N} \leq C_{2N} (2N)^{p_{2N}} \leq C (2N)^{p_N}$.
	 
	 TODO ...
	 
	\begin{align*}
		\log(y_{2N}) - \log(y_N) = \log\left(\frac{y_{2N}}{y_N}\right) = \log\left(\frac{C(2N)^{p_N}}{C\cdot N^{p_N}}\right) = \log(2^{p_N}) = p_N \log(2) \\
		\implies p_N = \frac{\log(y_{2N}) - \log(y_N)}{\log(2)}
	\end{align*}
\end{proof}

\subsection*{Teilaufgabe 1b:}
TODO Angabe 1b

\begin{proof}
	
	\begin{align*}
		\lim\limits_{n\rightarrow\infty} \log\left(\frac{C+\delta_{2N}}{C+\delta_N}\right) = \log\left(\lim\limits_{n\rightarrow\infty}\frac{C+\delta_{2N}}{C+\delta_N}\right) = \log\left(\frac{\lim\limits_{n\rightarrow\infty}C+\delta_{2N}}{\lim\limits_{n\rightarrow\infty}C+\delta_N}\right) = \log\left(\frac{C}{C}\right) = \log(1) = 0\\
		\implies
		p_N = \frac{\log(y_{2N}) - \log(y_N)}{\log(2)} = \frac{\log((C+\delta_{2N})(2N)^p) - \log((C+\delta_N)N^p)}{\log(2)} = \frac{\log\left(\frac{(C+\delta_{2N})(2N)^p}{(C+\delta_N)N^p}\right)}{\log(2)} \\
		= \frac{\log\left(\frac{(C+\delta_{2N})2^p}{(C+\delta_N)}\right)}{\log(2)} = \frac{p \log(2) + \log\left(\frac{C+\delta_{2N}}{C+\delta_N}\right)}{\log(2)} = p + \frac{\log\left(\frac{C+\delta_{2N}}{C+\delta_N}\right)}{\log(2)} \xrightarrow{n\rightarrow\infty} p + 0 = p		
	\end{align*}
\end{proof}

\subsection*{Teilaufgabe 1c:}
TODO Angabe 1c

Darstellung ist Gerade. $c = f(1)$ und $p$ ist Steigung, wenn beide Achsen ''gleich'' skaliert.

\section*{Aufgabe 2: Cholesky-Verfahren und Skyline-Matrizen}
\subsection*{Teilaufgabe 2a:}
TODO Angabe 2a

\begin{proof}
	TODO Beweis 2a aufschreiben
\end{proof}

\subsection*{Teilaufgabe 2b:}

\begin{proof}
	TODO Beweis 2b
\end{proof}

\section*{Aufgabe 3: Pseudocode für Cholesky-Zerlegung von Skyline-Matrizen}
\subsection{Teilaufgabe 3a:}
TODO Angabe 3a

TODO Pseudocode

\subsection*{Teilaufgabe 3b:}
TODO Angabe 3b

TODO Pseudocode aufschreiben

\section*{Aufgabe 4: Aufwand des Algorithmus und Verhalten in Spezialfällen}
\subsection*{Teilaufgabe 4a:}
TODO Angabe 4a

TODO Aufwand bestimmen

\subsection*{Teilaufgabe 4b:}
TODO Angabe 4b

linke Matrix ist quasi vollbesetzt als Skyline-Matrix (mit Nulleinträgen!)

rechte Matrix hat p=q=0 für alle außer letzte Zeile dort p=q=n

effizientere berechnung der cholesky-Zerlegung durch ''spiegeln''. Also aus $A \in \mathbb{R}^{n\times n}$ mache $B \in \mathbb{R}^{n\times n}$ durch $B_{i,j} = A_{(n+1-i),(n+1-j)}$. Umkehrabbildung ist gleich (auch $(i, j) \mapsto (n+1-i, n+1-j)$). Dann erhält man eine Matrix mit der rechten Form, kann die cholesky-zerlegung $LL^T=B$ berechnen und erhält dann, dass $L$ gespiegelt (auch wieder gleich) eine untere Dreiecksmatrix mit $\hat{L}\hat{L}^T=A$.

\section*{Aufgabe 5: Implementierung des Algorithmus und empirische Aufwandsschätzung}
TODO Angabe 5

TODO Anhang Python-Code (+ Grafik Performance?)


\end{document}
